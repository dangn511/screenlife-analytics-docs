(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{287:function(e,t,a){"use strict";a.r(t);var s=a(14),o=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"screenlife-analytics-handover-documentation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#screenlife-analytics-handover-documentation"}},[e._v("#")]),e._v(" Screenlife Analytics - handover documentation")]),e._v(" "),t("p",[e._v("To the new person taking over this project, good luck with your work and sorry for the mess. I took a messy open source codebase, and added more mess to the pile. So that you won't have to waste a month figuring out what the hell is all this doing, like I did, this is a comprehensive guide for the Screenlife Analytics platform, including a clear explanation of the codebase.")]),e._v(" "),t("p",[e._v("I hope this guide will be useful for you, and once you're done with the project, add on to this for archive. The world needs more clear and usable documentations.")]),e._v(" "),t("h2",{attrs:{id:"quick-guide"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#quick-guide"}},[e._v("#")]),e._v(" Quick guide")]),e._v(" "),t("p",[e._v("The repo for the Analytics app is found "),t("a",{attrs:{href:"https://github.com/ScreenLife-Capture-Team/screenlife-analytics/tree/dev",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),t("OutboundLink")],1),e._v(". My last update was on the dev branch, but as of now it probably can be merged back into main.")]),e._v(" "),t("h3",{attrs:{id:"running-steps"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#running-steps"}},[e._v("#")]),e._v(" Running steps")]),e._v(" "),t("p",[e._v("The steps for installing and using the app can be found in the readme on dev branch")]),e._v(" "),t("h2",{attrs:{id:"code-breakdown-deployment"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#code-breakdown-deployment"}},[e._v("#")]),e._v(" Code breakdown: Deployment")]),e._v(" "),t("h3",{attrs:{id:"compose-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#compose-file"}},[e._v("#")]),e._v(" Compose file")]),e._v(" "),t("p",[e._v("For building purposes, thus far I've only used "),t("code",[e._v("docker-compose.dev.yml")]),e._v(". You will see in the compose file, under "),t("code",[e._v("services")]),e._v(", there are 5 images to be deployed. The compose file will read the Dockerfiles at each location to build the images.")]),e._v(" "),t("h4",{attrs:{id:"front-end"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#front-end"}},[e._v("#")]),e._v(" Front end")]),e._v(" "),t("p",[t("code",[e._v("annotator_client")]),e._v(" is of course the client facing side. Code for all the frontend stuff is in the "),t("code",[e._v("client")]),e._v(" directory. The client has another Dockerfile inside to be used for deployment at "),t("code",[e._v("./client/Dockerfile")]),e._v(". We'll get to that later below.")]),e._v(" "),t("h4",{attrs:{id:"backend"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#backend"}},[e._v("#")]),e._v(" Backend")]),e._v(" "),t("p",[t("code",[e._v("annotator_webserver")]),e._v(" is the Flask backend server. It also has a Dockerfile to be read at "),t("code",[e._v("./backend/webserver/Dockerfile")]),e._v(".")]),e._v(" "),t("h4",{attrs:{id:"workers"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#workers"}},[e._v("#")]),e._v(" Workers")]),e._v(" "),t("p",[t("code",[e._v("annotator_workers")]),e._v(" is a server to manage workers, to perform asynchronous tasks. These workers will be handling a majority of API calls, interacting with the database. Its Dockerfile is at "),t("code",[e._v("./backend/workers/Dockerfile")])]),e._v(" "),t("h4",{attrs:{id:"database"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#database"}},[e._v("#")]),e._v(" Database")]),e._v(" "),t("p",[e._v("This image uses the stock Mongo image from Docker to build. It does not have a Dockerfile.")]),e._v(" "),t("p",[e._v("However, note that "),t("strong",[e._v("this image is not where data is stored")]),e._v(". Data will be stored in a volume called "),t("code",[e._v("mongodb_data")]),e._v(".")]),e._v(" "),t("h4",{attrs:{id:"messageq"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#messageq"}},[e._v("#")]),e._v(" Messageq")]),e._v(" "),t("p",[e._v("Built using the stock RabbitMQ image. This one is mostly stable, it should be left alone unless you need to upgrade/downgrade RabbitMQ.")]),e._v(" "),t("h3",{attrs:{id:"individual-dockerfiles"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#individual-dockerfiles"}},[e._v("#")]),e._v(" Individual Dockerfiles")]),e._v(" "),t("h4",{attrs:{id:"client"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#client"}},[e._v("#")]),e._v(" Client")]),e._v(" "),t("p",[e._v("Our client image is built upon Node 10, using Vue-cli 3.4.0. The client access point for public access or dev access is at port 8080.")]),e._v(" "),t("p",[e._v("But also, take a look at "),t("code",[e._v("vue.config.js")]),e._v(". I've set "),t("code",[e._v("publicPath")]),e._v(" to screenlife-analytics. That means, access to client will be at "),t("code",[e._v("<ip_address>:8080/screenlife-analytics")]),e._v(". After deploying locally, you will access it at "),t("code",[e._v("localhost:8080/screenlife-analytics/")])]),e._v(" "),t("h4",{attrs:{id:"backend-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#backend-2"}},[e._v("#")]),e._v(" Backend")]),e._v(" "),t("p",[e._v("This file has quite a lot to look at. Our starting point is the GPU enabled Tensorflow image "),t("code",[e._v("tensorflow/tensorflow:1.15.4-gpu-py3")]),e._v(". After that, it's a matter of installing a ton of dependencies before we can start. I highly suggest you should save this image and upload to Dockerhub for future use, otherwise it takes time to rebuild every time you start fresh.")]),e._v(" "),t("p",[e._v("Backend is exposed at port 8081. In the init file for our Flask server ("),t("code",[e._v("backend/webserver/api")]),e._v("), I've prefixed the URL for API endpoint to be "),t("code",[e._v("api-screenlife")]),e._v(". Again, look at the "),t("code",[e._v("proxy")]),e._v(" section in "),t("code",[e._v("Vue.config.js")]),e._v(". I've set "),t("code",[e._v(":8081/api-screenlife")]),e._v(" to "),t("code",[e._v("/api-screenlife")]),e._v(". That means, "),t("code",[e._v(":8080/api-screenlife")]),e._v(" will also point at the server access point.")]),e._v(" "),t("h4",{attrs:{id:"workers-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#workers-2"}},[e._v("#")]),e._v(" Workers")]),e._v(" "),t("p",[e._v("The workers image is also built upon "),t("code",[e._v("tensorflow/tensorflow:1.15.4-gpu-py3")]),e._v(". Workers image endpoint is at port 5555.")]),e._v(" "),t("h2",{attrs:{id:"code-breakdown-client"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#code-breakdown-client"}},[e._v("#")]),e._v(" Code breakdown: Client")]),e._v(" "),t("p",[e._v("Now, we're taking a dive into the fuckfest that is "),t("code",[e._v("./client")])]),e._v(" "),t("h3",{attrs:{id:"entry-point"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#entry-point"}},[e._v("#")]),e._v(" Entry point")]),e._v(" "),t("p",[e._v("As usual, our entry point is the "),t("code",[e._v("App.vue")]),e._v(" file. You'll notice that it only has two components: the Navbar, and a RouterView. Every web content we see on the page is within this RouterView component.")]),e._v(" "),t("h3",{attrs:{id:"router"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#router"}},[e._v("#")]),e._v(" Router")]),e._v(" "),t("p",[e._v("The "),t("code",[e._v("router.js")]),e._v(" is, as usual, where the index for the pages are. They are all located under "),t("code",[e._v("./client/src/views")])]),e._v(" "),t("p",[e._v("Note the "),t("code",[e._v("requiresAuth: true")]),e._v(" for most routes. This is to ensure no unauthorized access to any component page, unless the user has already logged in.")]),e._v(" "),t("p",[e._v("The auth and rerouting process can be found in "),t("code",[e._v("main,js")]),e._v(" in the "),t("code",[e._v("router.beforeEach")]),e._v(" definition.")]),e._v(" "),t("h3",{attrs:{id:"views"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#views"}},[e._v("#")]),e._v(" Views")]),e._v(" "),t("h4",{attrs:{id:"about"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#about"}},[e._v("#")]),e._v(" About")]),e._v(" "),t("p",[e._v("This page is meant to be an FAQ for the webapp, but for now it's blank. You can build this up after you're done fully developing the app.")]),e._v(" "),t("h4",{attrs:{id:"adminpanel"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#adminpanel"}},[e._v("#")]),e._v(" AdminPanel")]),e._v(" "),t("p",[e._v("In the Navbar component, you will see that this page's access is restricted only to admin. This is where the admin can manage users, including creating and granting access.")]),e._v(" "),t("h4",{attrs:{id:"annotator"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#annotator"}},[e._v("#")]),e._v(" Annotator")]),e._v(" "),t("p",[e._v("The page for image segmentation. Also the most goddamn annoying page of all.")]),e._v(" "),t("h4",{attrs:{id:"auth"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#auth"}},[e._v("#")]),e._v(" Auth")]),e._v(" "),t("p",[e._v("The login page. Only shown upon first accessing the page. This is where, if authentication guard triggers, the user will be sent to.")]),e._v(" "),t("h4",{attrs:{id:"categories"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#categories"}},[e._v("#")]),e._v(" Categories")]),e._v(" "),t("p",[e._v("This is a leftover from the original authors, and for the sake of avoiding confusion, I've purposely hidden it from normal users. It displays all the categories that has been created.")]),e._v(" "),t("p",[e._v("Because of how the deletion works in this app, removing a category doesn't actually erase it from the database. I've developed the workflow for users to add/remove categories in the annotation pages itself. Long story short, this page is somewhat redundant now.")]),e._v(" "),t("h4",{attrs:{id:"dataset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dataset"}},[e._v("#")]),e._v(" Dataset")]),e._v(" "),t("p",[e._v("Not to be confused with Datasets.")]),e._v(" "),t("p",[e._v("This is the most extensive one, which is the page that shows after you click on a dataset from the home page. In this page, navigation is done using the variable "),t("code",[e._v("tab")]),e._v(". Changing it will display the corresponding "),t("code",[e._v("div")]),e._v(" in the HTML code.")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("batchtag")]),e._v(": The default tab. This is where batch annotation is performed.")]),e._v(" "),t("li",[t("code",[e._v("images")]),e._v(": This is for selecting individual images for image segmentation task.")]),e._v(" "),t("li",[t("code",[e._v("exports")]),e._v(": For user to download the exported data or tagsets.")]),e._v(" "),t("li",[t("code",[e._v("analytics")]),e._v(": The dashboard where data visualization is shown.")]),e._v(" "),t("li",[t("code",[e._v("searchbar")]),e._v(": Search function.")])]),e._v(" "),t("h4",{attrs:{id:"datasets"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#datasets"}},[e._v("#")]),e._v(" Datasets")]),e._v(" "),t("p",[e._v("Not to be confused with Dataset.")]),e._v(" "),t("p",[e._v("The de facto homepage of the webapp. This is where user sees the datasets that's been assigned to them. Clicking on one will go to "),t("code",[e._v("Dataset.vue")]),e._v(".")]),e._v(" "),t("h4",{attrs:{id:"help"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#help"}},[e._v("#")]),e._v(" Help")]),e._v(" "),t("p",[e._v("My attempt at a FAQ page, which wasn't finished.")]),e._v(" "),t("h4",{attrs:{id:"home"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#home"}},[e._v("#")]),e._v(" Home")]),e._v(" "),t("p",[e._v("Redundant page. Pretty much can ignore")]),e._v(" "),t("h4",{attrs:{id:"pagenotfound"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#pagenotfound"}},[e._v("#")]),e._v(" PageNotFound")]),e._v(" "),t("p",[e._v("The 404 page")]),e._v(" "),t("h4",{attrs:{id:"tasks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tasks"}},[e._v("#")]),e._v(" Tasks")]),e._v(" "),t("p",[e._v("This one is also only visible to admin. This is where the workers will report their task progress when summoned.")]),e._v(" "),t("p",[e._v("It's no longer useful for average users, but a great way to help you debug issues with workers.")]),e._v(" "),t("h4",{attrs:{id:"undo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#undo"}},[e._v("#")]),e._v(" Undo")]),e._v(" "),t("p",[e._v("A legacy from the original authors. This is supposed to be where you can remove data from the database entirely. I admit I haven't really looked into it; but you can if it helps in future development.")]),e._v(" "),t("h4",{attrs:{id:"user"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#user"}},[e._v("#")]),e._v(" User")]),e._v(" "),t("p",[e._v("For users to update their profile and password.")]),e._v(" "),t("h2",{attrs:{id:"code-breakdown-how-an-api-call-is-handled-from-client-to-backend"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#code-breakdown-how-an-api-call-is-handled-from-client-to-backend"}},[e._v("#")]),e._v(" Code breakdown: How an API call is handled, from client to backend")]),e._v(" "),t("p",[e._v("When a user does any action on the client, here is the long winded ass process of how methods are called")]),e._v(" "),t("h3",{attrs:{id:"predefined-axios-requests"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#predefined-axios-requests"}},[e._v("#")]),e._v(" Predefined Axios requests")]),e._v(" "),t("p",[e._v("Axios is there to help you with constructing HTTP requests.")]),e._v(" "),t("p",[e._v("Predefined HTTP requests can be found in "),t("code",[e._v("./client/src/models")]),e._v(".  Each of them is dedicated for an API, which can be found at "),t("code",[e._v("./backend/webserver/api")]),e._v(".")]),e._v(" "),t("p",[e._v("You can of course use Axios on its own to send custom HTTP requests within the Vue pages/components.")]),e._v(" "),t("h3",{attrs:{id:"the-process"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#the-process"}},[e._v("#")]),e._v(" The process")]),e._v(" "),t("h4",{attrs:{id:"sending-the-request"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sending-the-request"}},[e._v("#")]),e._v(" Sending the request")]),e._v(" "),t("p",[e._v("HTTP request is sent from client to webserver when you either use Axios raw to build a request and send, or trigger a function call in one of the "),t("code",[e._v("models")]),e._v(" files listed above.")]),e._v(" "),t("h4",{attrs:{id:"receiving-the-request"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#receiving-the-request"}},[e._v("#")]),e._v(" Receiving the request")]),e._v(" "),t("p",[e._v("Receiving request is handled by the APIs in Flask (found at "),t("code",[e._v("./backend/webserver/api")]),e._v(").")]),e._v(" "),t("p",[e._v("Some simple ones will get a return immediately in the API code. Other requests, particularly requests regarding reading/modifying database might need to trigger more layers of function calls.")]),e._v(" "),t("h4",{attrs:{id:"database-code"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#database-code"}},[e._v("#")]),e._v(" Database code")]),e._v(" "),t("p",[e._v("These code are found in "),t("code",[e._v("./backend/database")]),e._v(". They are class objects that inherit MongoEngine's "),t("code",[e._v("DynamicDocument")]),e._v(" class. Read "),t("a",{attrs:{href:"https://docs.mongoengine.org/guide/defining-documents.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),t("OutboundLink")],1),e._v(" to understand more about MongoEngine's classes if you're not yet familiar.")]),e._v(" "),t("p",[e._v("Essentially these classes represent data tables in MongoDB, where the class attributes are fields in the database. Modification of the DB is carried out through class methods.")]),e._v(" "),t("p",[e._v("Tasks that take long to perform will be handed over to workers, to perform asynchronously in the background.")]),e._v(" "),t("h4",{attrs:{id:"workers-and-tasks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#workers-and-tasks"}},[e._v("#")]),e._v(" Workers and tasks")]),e._v(" "),t("p",[e._v("We're using Celery as the worker manager, with RabbitMQ being the task broker.")]),e._v(" "),t("p",[e._v("Workers can also call database code (DynamicDocument class objects) to perform database operations.")]),e._v(" "),t("p",[e._v("It is important to remember that workers are meant to be working in the background. Therefore, API calls that spawn workers should not await the worker's result. In those case, ensure that:")]),e._v(" "),t("ul",[t("li",[e._v("the database class methods that spawn workers should return the task's metadata (task ID, task name etc)")]),e._v(" "),t("li",[e._v("the backend API should expect a return of that too")]),e._v(" "),t("li",[e._v("API should respond to client similarly with task metadata, or a simple acknowledgement.")])]),e._v(" "),t("p",[e._v("To see a good example of how this process goes, take a look at "),t("code",[e._v("./backend/webserver/api/datasets.py")]),e._v(", in the "),t("code",[e._v("DatasetExport")]),e._v(" class (route "),t("code",[e._v("/<int:dataset_id>/export")]),e._v(")")]),e._v(" "),t("h3",{attrs:{id:"debugging-database-operations-api-backend"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#debugging-database-operations-api-backend"}},[e._v("#")]),e._v(" Debugging database operations/API backend")]),e._v(" "),t("p",[e._v("Note that in a Docker environment, "),t("code",[e._v("print")]),e._v(" statements in Flask and MongoEngine code won't display to CLI. For that, you need to use the Gunicorn "),t("code",[e._v("logger")]),e._v(", as defined for example in "),t("code",[e._v("./backend/webserver/__init__.py")]),e._v(" or "),t("code",[e._v("./backend/database/__init__.py")]),e._v(".")])])}),[],!1,null,null,null);t.default=o.exports}}]);